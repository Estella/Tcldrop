#! /bin/sh
# \
# Nice little hack to find latest version of tclsh in PATH \
# \
# NOTE: backslash and semicolon placements are important! \
# \
# Search for tclsh[0-9].[0-9] in each valid dir in PATH \
for dir in $(echo $PATH | sed 's/:/ /g'); \
do \
  if test -d $dir; \
  then \
    files=$(/bin/ls $dir | egrep '^tclsh[0-9]\.[0-9]$'); \
    if test "$files" != ""; \
    then \
      versions="${versions:+$versions }$(echo $files | sed 's/tclsh//g')"; \
    fi; \
  fi; \
done; \
# Loop over each version to find the latest version of tclsh \
for ver in $versions; \
do \
  tmpver=$(echo $ver | sed 's/\.//g'); \
  if test "$lasttmpver" != ""; \
  then \
    if test "$tmpver" -gt "$lasttmpver"; \
    then \
      lastver=$ver; \
      lasttmpver=$tmpver; \
    fi; \
  else \
    lastver=$ver; \
    lasttmpver=$tmpver; \
  fi; \
done; \
# Use the latest tclsh version found, otherwise fall back to 'tclsh' \
exec tclsh$lastver "$0" ${1+"$@"}

# Copyright (C) 2003,2004,2005,2006,2007,2008,2009 Tcldrop-Dev <Tcldrop-Dev@Tcldrop.US>
#
# $Id$
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see gpl.txt); if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
# Or visit http://www.GNU.Org/licenses/gpl.html
#
# The author of this project can be reached at FireEgl@Tcldrop.US
# Or can be found on IRC (EFNet or FreeNode) as FireEgl.

# This script is used to run Tcldrop in stand-alone (tclsh) mode ONLY.

# The command line options should be the same as in Eggdrop,
# except you can specify MULTIPLE configs here (separated by spaces).
# (One config for each Tcldrop you want to run)

# Command line arguments:
#  -h   help
#  -v   print version and exit
#  -n   don't go into the background
#  -c   (with -n) display channel stats every 10 seconds
#  -t   (with -n) use terminal to simulate dcc-chat
#  -m   userfile creation mode
#  optional config filename (default 'eggdrop.conf')
namespace eval ::tcldrop {
	variable tcldrop
	# On at least one FreeBSD box running tclsh8.4, argv gets reset after we source another script. So we store it here in the tcldrop array for later use:
	set tcldrop(argv) $::argv
	if {[catch { ::source [file join [file dirname [info script]] tcldrop.tcl] }]} { ::source tcldrop.tcl }
	set tcldrop(host_env) {tclsh}
	puts [Tcldrop run $tcldrop(argv)]
	variable Exit
	if {[info exists Exit]} { exit $Exit } elseif {$tcldrop(background-mode)} {
		if {![catch { package require critcl }]} {
			::critcl::cproc fork {} int { return fork(); }
			if {[llength [info commands fork]] && ![catch { fork } pid]} {
				if {$pid != 0} {
					puts "Launched into the background (using Critcl)  (pid: $pid)"
					exit 0
				} else {
					vwait ::tcldrop::Exit
					exit $Exit
				}
			}
		} elseif {![catch { package require Tclx }] && [llength [info commands fork]] && ![catch { fork } pid]} {
			if {$pid != 0} {
				puts "Launched into the background (using TclX)  (pid: $pid)"
				exit 0
			} else {
				vwait ::tcldrop::Exit
				exit $Exit
			}
		} elseif {![catch { package require Expect }] && [llength [info commands fork]] && ![catch { fork } pid]} {
			if {$pid != 0} {
				puts "Launched into the background (using Expect)  (pid: $pid)"
				exit 0
			} else {
				catch { disconnect }
				vwait ::tcldrop::Exit
				exit $Exit
			}
		} else {
			puts {Running in foreground mode. Install Tclx or Expect for background mode support.}
			set tcldrop(background-mode) 0
		}
	}
	puts "${::argv0}: Entering Tcl event-loop (vwait)"
	if {![catch { vwait ::tcldrop::Exit } error]} {
		catch { puts "Exiting with error level $Exit ... $error" }
	} else {
		catch { puts "Exiting with error level $Exit ... $error \n$::errorInfo" }
	}
	#catch { close stdout }
	#catch { close stdin }
	#catch { close stderr }
	set tcl_interactive 0
	exit $::tcldrop::Exit
}
